"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const node_path = require("node:path");
const fs = require("node:fs");
const transformLocalize = require("./transform-localize.cjs");
const sortObject = (o) => Object.fromEntries(
  Object.entries(o).sort(
    ([a], [b]) => a.localeCompare(b, "en", { sensitivity: "base" })
  )
);
function i18nPlugin(options = {}) {
  const {
    localesDir = "i18n",
    babelPlugins,
    addMissing = true,
    removeUnusedKeys = false,
    tabs
  } = options;
  let assetsDir = options.assetsDir;
  if (assetsDir && !assetsDir.endsWith("/")) assetsDir += "/";
  const locales = options.locales || ["en"];
  const defaultLocale = options.defaultLocale || locales[0];
  const localeNames = {};
  const localesDirAbs = node_path.resolve(localesDir);
  const localesDirNode = node_path.sep !== "/" ? localesDirAbs.replaceAll(node_path.sep, "/") : localesDirAbs;
  let shouldInline = false;
  let translations;
  let hasTabs;
  let allKeys;
  let pluralKeys;
  return [
    {
      name: "i18n",
      enforce: "pre",
      async config() {
        const updatedViteConfig = {
          optimizeDeps: {
            // Make sure we process our virtual files
            exclude: ["compiled-i18n"]
          },
          ssr: {
            // Make sure we bundle our module
            noExternal: ["compiled-i18n"]
          }
        };
        return updatedViteConfig;
      },
      configResolved(config) {
        shouldInline = !config.build.ssr && config.mode === "production";
        if (!assetsDir && config.plugins.some((p) => p.name === "vite-plugin-qwik"))
          assetsDir = "build/";
      },
      buildStart() {
        fs.mkdirSync(localesDirAbs, { recursive: true });
        const fallbacks = {};
        translations = {};
        hasTabs = {};
        allKeys = /* @__PURE__ */ new Set();
        pluralKeys = /* @__PURE__ */ new Set();
        for (const locale of locales) {
          const match = /^([a-z]{2})([_-]([A-Z]{2}))?$/.exec(locale);
          if (!match)
            throw new Error(
              `Invalid locale: ${locale} (does not match xx or xx_XX))`
            );
          const localeFile = node_path.resolve(localesDirAbs, `${locale}.json`);
          let data;
          if (fs.existsSync(localeFile)) {
            const text = fs.readFileSync(localeFile, "utf8");
            hasTabs[locale] = tabs ?? text.slice(0, 100).includes("	");
            data = JSON.parse(text);
            if (data.locale !== locale)
              throw new Error(
                `Invalid locale file: ${localeFile} (locale mismatch ${data.locale} !== ${locale})`
              );
            if (!data.name)
              data.name = match[3] ? `${match[1]} (${match[3]})` : locale;
            if (data.fallback) {
              if (!locales.includes(data.fallback))
                throw new Error(
                  `Invalid locale file: ${localeFile} (invalid fallback ${data.fallback})`
                );
              let follow;
              while (follow = fallbacks[data.fallback]) {
                if (follow === locale) {
                  throw new Error(
                    `Invalid locale file: ${localeFile} (circular fallback ${data.fallback})`
                  );
                }
              }
              fallbacks[locale] = data.fallback;
            }
          } else {
            data = {
              locale,
              name: match[3] ? `${match[1]} (${match[3]})` : locale,
              translations: {}
            };
            hasTabs[locale] = !!tabs;
            if (addMissing)
              fs.writeFileSync(
                localeFile,
                JSON.stringify(data, null, tabs ? "	" : 2)
              );
          }
          localeNames[locale] = data.name;
          translations[locale] = data;
          for (const [key, tr] of Object.entries(data.translations))
            if (tr && typeof tr === "object") pluralKeys.add(key);
        }
      },
      // Redirect to our virtual data files
      async resolveId(id) {
        if (id.startsWith("@i18n/__locales")) return "\0i18n-locales.js";
        if (id.startsWith("@i18n/__data")) return "\0i18n-data.js";
        if (id.startsWith("@i18n/__state")) return "\0i18n-state.js";
      },
      // Load our virtual data files
      async load(id) {
        if (id === "\0i18n-locales.js") {
          return `
/**
 * This file was generated by compiled-i18n.
 *
 * For server builds, it contains all translations. For client builds, it is
 * empty, and translations need to be loaded dynamically.
 */
${shouldInline ? `export default {"__$LOCALE$__": {translations: {}}}` : `
${locales.map((l, i) => `import _${i} from '${localesDirNode}/${l}.json'`).join("\n")}

export default {
${locales.map((l, i) => `  "${l}": _${i},`).join("\n")}
}
`}
`;
        }
        if (id === "\0i18n-data.js") {
          return `
/** This file is generated at build time by \`compiled-i18n\`. */
/** @type {import('compiled-i18n').Locale[]} */
export const locales = ${JSON.stringify(locales)}
/** @type {Record<import('compiled-i18n').Locale, string>} */
export const localeNames = ${JSON.stringify(localeNames)}
`;
        }
        if (id === "\0i18n-state.js") {
          return `
/** This file is generated at build time by \`compiled-i18n\`. */
import {localeNames} from '@i18n/__data.js'

/** @typedef {import('compiled-i18n').Locale} Locale */
/** @type {Locale} */
export let defaultLocale = ${JSON.stringify(defaultLocale)}
/** @type {Locale} */
export let currentLocale${shouldInline ? ' = "__$LOCALE$__"' : ""}

${shouldInline ? (
            // These functions shouldn't be called from client code
            `
export let getLocale = () => "__$LOCALE$__"
export const setDefaultLocale = () => {}
export const setLocaleGetter = () => {throw new Error('Do not call setLocaleGetter() in client code, use the html lang attribute or setDefaultLocale() (which only works in dev mode)')}
			`
          ) : `
/** @type {() => Locale} */
export let getLocale = () => {
	if (currentLocale) return currentLocale
	if (typeof document !== 'undefined') {
		const lang = document.documentElement.lang
		if (lang && lang in localeNames) currentLocale = lang
	}
	if (!currentLocale) currentLocale = defaultLocale
	return currentLocale
}
const _checkLocale = l => {
	if (!localeNames[l]) {
		console.error(\`unknown locale \${l}\`)
		return defaultLocale
	}
	return l
}
/** @type {(locale: Locale) => void} */
export const setDefaultLocale = l => {
	defaultLocale = _checkLocale(l)
}
/** @type {(fn: () => Locale | undefined) => void} */
export const setLocaleGetter = fn => {
	getLocale = () => currentLocale = _checkLocale(fn())
}`}
`;
        }
      },
      async transform(code, id) {
        if (!shouldInline || !/\.(cjs|js|mjs|ts|jsx|tsx)($|\?)/.test(id))
          return null;
        return transformLocalize.transformLocalize({ id, code, allKeys, pluralKeys, babelPlugins });
      }
    },
    {
      name: "i18n-post",
      enforce: "post",
      // Emit the translated files as assets under locale subdirectories
      generateBundle: {
        // enforce isn't enough to make hooks be post, so we need to set the order
        order: "post",
        handler(_options, bundle) {
          if (!shouldInline) return;
          for (const [fileName, chunk] of Object.entries(bundle)) {
            if (assetsDir && !fileName.startsWith(assetsDir)) continue;
            for (const locale of locales) {
              const newFilename = assetsDir ? `${assetsDir}${locale}/${fileName.slice(assetsDir.length)}` : `${locale}/${fileName}`;
              let source = chunk.type === "asset" ? chunk.source : chunk.code;
              if (fileName.endsWith("js") && typeof source === "string") {
                source = transformLocalize.replaceGlobals({
                  code: source,
                  locale,
                  translations
                });
              }
              this.emitFile({
                type: "asset",
                fileName: newFilename,
                source
              });
            }
          }
        }
      },
      buildEnd() {
        if (!shouldInline) return;
        for (const locale of locales) {
          const missingKeys = new Set(allKeys);
          const unusedKeys = /* @__PURE__ */ new Set();
          for (const key of Object.keys(translations[locale].translations)) {
            missingKeys.delete(key);
            if (!allKeys.has(key)) unusedKeys.add(key);
          }
          if (missingKeys.size || unusedKeys.size)
            console.info(
              `i18n ${locale}: ${missingKeys.size ? `missing ${missingKeys.size} keys: ${[...missingKeys].map((k) => `"${k}"`).join(" ")}` : ""}${missingKeys.size && unusedKeys.size ? ", " : ""}${unusedKeys.size ? `unused ${unusedKeys.size} keys${removeUnusedKeys ? " (will be deleted now)" : ""}: ${[
                ...unusedKeys
              ].map((k) => `"${k}"`).join(" ")}` : ""}`
            );
          if (removeUnusedKeys && unusedKeys.size) {
            for (const key of unusedKeys) {
              delete translations[locale].translations[key];
            }
            const data = translations[locale];
            sortObject(data.translations);
            fs.writeFileSync(
              node_path.resolve(localesDirAbs, `${locale}.json`),
              JSON.stringify(data, null, hasTabs[locale] ? "	" : 2)
            );
          }
          if (addMissing && missingKeys.size) {
            for (const key of missingKeys) {
              translations[locale].translations[key] = "";
            }
            const data = translations[locale];
            sortObject(data.translations);
            fs.writeFileSync(
              node_path.resolve(localesDirAbs, `${locale}.json`),
              JSON.stringify(data, null, hasTabs[locale] ? "	" : 2)
            );
          }
        }
      }
    }
  ];
}
exports.i18nPlugin = i18nPlugin;
